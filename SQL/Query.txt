// КНИЖНЫЙ МАГАЗИН
==================

// Найти среднюю цену книг каждого автора:
SELECT author, ROUND(AVG(price),2) AS Средняя_цена 
FROM book 
GROUP BY author;

// Вывести суммарную стоимость книг каждого автора:
SELECT author, SUM(price * amount) AS Стоимость 
FROM book 
GROUP BY author;

// Найти минимальную и максимальную цену книг всех авторов, общая стоимость книг которых больше 5000. Результат вывести по убыванию минимальной цены.:
SELECT author, MIN(price) AS Минимальная_цена, MAX(price) AS Максимальная_цена 
FROM book 
GROUP BY author 
HAVING SUM(price * amount) > 5000 
ORDER BY Минимальная_цена DESC;

// Вывести максимальную и минимальную цену книг каждого автора, кроме Есенина, количество экземпляров книг которого больше 10:
SELECT author, MIN(price) AS Минимальная_цена, MAX(price) AS Максимальная_цена 
FROM book 
WHERE author <> 'Есенин С.А.' 
GROUP BY author 
HAVING SUM(amount) > 10;

// Вывести информацию о книгах тех авторов, общее количество экземпляров книг которых не менее 12:
SELECT title, author, amount, price 
FROM book 
WHERE author IN (SELECT author FROM book GROUP BY author HAVING SUM(amount) >= 12 );

// Вывести информацию о тех книгах, количество которых меньше самого маленького среднего количества книг каждого автора:
SELECT title, author, amount, price 
FROM book 
WHERE amount < ALL (SELECT AVG(amount) FROM book GROUP BY author );

// Вывести информацию о тех книгах, количество которых меньше самого большого среднего количества книг каждого автора:
SELECT title, author, amount, price 
FROM book 
WHERE amount < ANY ( SELECT AVG(amount) FROM book GROUP BY author );

// Вывести информацию о книгах, количество экземпляров которых отличается от среднего количества экземпляров книг на складе более чем на 3,  а также указать среднее значение количества экземпляров книг:
SELECT title, author, amount, ( SELECT AVG(amount) FROM book ) AS Среднее_количество 
FROM book 
WHERE abs(amount - (SELECT AVG(amount) FROM book)) >3;

// Посчитать сколько и каких экземпляров книг нужно заказать поставщикам, чтобы на складе стало одинаковое количество экземпляров каждой книги, равное значению самого большего количества экземпляров одной книги на складе:
SELECT title, author, amount, (SELECT MAX(amount) FROM book) - amount AS Заказ 
FROM book 
WHERE amount < (SELECT MAX(amount) FROM book);

// В таблице book необходимо скорректировать значение для покупателя в столбце buy таким образом, чтобы оно не превышало количество экземпляров книг, указанных в столбце amount. А цену тех книг, которые покупатель не заказывал, снизить на 10%:
UPDATE book 
SET buy = IF (buy > amount, amount, buy), price = IF (buy=0, price*0.9, price);

// КОМАНДИРОВКИ
===============

// Вывести информацию о командировках во все города кроме Москвы и Санкт-Петербурга (фамилии и инициалы сотрудников, город, длительность командировки в днях, при этом первый и последний день относится к периоду командировки). Последний столбец назвать Длительность. Информацию вывести в упорядоченном по убыванию длительности поездки, а потом по убыванию названий городов (в обратном алфавитном порядке):
SELECT name, city, DATEDIFF (date_last, date_first)+1 AS Длительность
FROM trip WHERE city NOT IN ('Москва', 'Санкт-Петербург') 
ORDER BY 3 DESC, 2 DESC;

// Вывести информацию о командировках сотрудника(ов), которые были самыми короткими по времени:
SELECT name, city, date_first, date_last 
FROM trip 
WHERE (DATEDIFF(date_last, date_first)+1) = (SELECT MIN(DATEDIFF(date_last, date_first)+1) FROM trip);

// Вывести сумму суточных (произведение количества дней командировки и размера суточных) для командировок, первый день которых пришелся на февраль или март 2020 года:
SELECT name, city, date_first, per_diem*(DATEDIFF(date_last, date_first)+1) Сумма
FROM trip 
WHERE (month(date_first) IN (02, 03)) AND year(date_first)=2020 
ORDER BY 1, 4 DESC;

// Вывести фамилию с инициалами и общую сумму суточных, полученных за все командировки для тех сотрудников, которые были в командировках больше чем 3 раза, в отсортированном по убыванию сумм суточных виде:
SELECT name, SUM(per_diem*(DATEDIFF(date_last, date_first) + 1)) Сумма
FROM trip 
GROUP BY name 
HAVING COUNT(name)>3 
ORDER BY 2 desc;

// ШТРАФЫ ГИБДД
===============

// Занести в таблицу fine суммы штрафов, которые должен оплатить водитель, в соответствии с данными из таблицы traffic_violation. При этом суммы заносить только в пустые поля столбца sum_fine:
UPDATE fine f, traffic_violation tv 
SET f.sum_fine = tv.sum_fine 
WHERE tv.violation = f.violation and f.sum_fine IS Null;
 
// В таблице fine увеличить в два раза сумму неоплаченных штрафов для отобранных на предыдущем шаге записей. 
UPDATE fine f, 
(SELECT name, number_plate, violation FROM fine 
GROUP BY name, number_plate, violation 
HAVING count(number_plate)>=2 AND count(violation)>=2) AS q 
SET sum_fine = sum_fine*2 
WHERE f.name = q.name AND f.number_plate = q.number_plate AND f.violation = q.violation AND date_payment IS NULL;

// Необходимо:
• в таблицу fine занести дату оплаты соответствующего штрафа из таблицы payment; 
• уменьшить начисленный штраф в таблице fine в два раза  (только для тех штрафов, информация о которых занесена в таблицу payment) , если оплата произведена не позднее 20 дней со дня нарушения.
UPDATE fine f, payment p 
SET f.date_payment = p.date_payment, f.sum_fine = IF (DATEDIFF(p.date_payment, f.date_violation)<=20, f.sum_fine/2, f.sum_fine)
WHERE (f.name,f.number_plate,f.violation) = (p.name,p.number_plate,p.violation) AND f.date_payment IS Null;

// Создать новую таблицу back_payment, куда внести информацию о неоплаченных штрафах (Фамилию и инициалы водителя, номер машины, нарушение, сумму штрафа  и  дату нарушения) из таблицы fine.
CREATE TABLE back_payment 
SELECT name, number_plate, violation, sum_fine, date_violation 
FROM fine WHERE date_payment IS NULL;

// JOIN&UNION
=============

В таблице city для каждого города указано количество дней, за которые заказ может быть доставлен в этот город (рассматривается только этап "Транспортировка"). Для тех заказов, которые прошли этап транспортировки, вывести количество дней за которое заказ реально доставлен в город. А также, если заказ доставлен с опозданием, указать количество дней задержки, в противном случае вывести 0. В результат включить номер заказа (buy_id), а также вычисляемые столбцы Количество_дней и Опоздание. Информацию вывести в отсортированном по номеру заказа виде. 
SELECT buy_step.buy_id, DATEDIFF(date_step_end, date_step_beg) Количество_дней, 
IF (city.days_delivery >= DATEDIFF(date_step_end, date_step_beg), 0, 
(DATEDIFF(date_step_end, date_step_beg) - city.days_delivery)) Опоздание
FROM buy_step JOIN buy USING (buy_id)  JOIN client USING (client_id) JOIN city USING (city_id)
WHERE buy_step.step_id = 3 AND date_step_end IS NOT NULL;max

// Для каждой отдельной книги необходимо вывести информацию о количестве проданных экземпляров и их стоимости за текущий и предыдущий год. Вычисляемые столбцы назвать Количество и Сумма. Информацию отсортировать по убыванию стоимости.
SELECT title, SUM(tab.kol) Количество, SUM(tab.su) Сумма 
FROM (SELECT title, SUM(buy_archive.amount) AS kol, SUM(buy_archive.price*buy_archive.amount) AS su
FROM buy_archive JOIN book using (book_id)
GROUP BY title
UNION ALL
SELECT title, SUM(buy_book.amount), SUM(book.price*buy_book.amount) 
FROM book JOIN buy_book USING (book_id) JOIN buy_step USING (buy_id) 
WHERE date_step_end IS NOT NULL and buy_step.step_id = 1
GROUP BY title) AS tab
GROUP BY title
ORDER BY Сумма DESC;

// Посчитать, сколько дополнительных баллов получит каждый абитуриент. Столбец с дополнительными баллами назвать Бонус. Информацию вывести в отсортированном по фамилиям виде.
SELECT name_enrollee, IFNULL(SUM(bonus),0) Бонус FROM enrollee 
LEFT JOIN enrollee_achievement USING (enrollee_id) 
LEFT JOIN achievement USING (achievement_id)
GROUP BY 1 ORDER BY 1;
